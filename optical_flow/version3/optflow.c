/* lk_baremetal_frames.c
   Compile:
     Host test: gcc -O3 -DHOST -o lk_host lk_baremetal_frames.c -lm
     RISC-V (pk): riscv64-linux-gnu-gcc -O3 -o lk_rv lk_baremetal_frames.c -lm
     Bare-metal (embed headers): riscv64-unknown-elf-gcc -O3 -march=rv64imac -mabi=lp64 -o lk_bare.elf lk_baremetal_frames.c

   In all cases, put generated headers (images_index.h and image_XXXX.h files) in the include path.
*/

#include <stdint.h>
#include <stddef.h>

#include "images_index.h"  // generated by Python -> defines IMG_WIDTH, IMG_HEIGHT, IMG_COUNT and frames[]

// ---------- configuration ----------
#ifndef WIN_RADIUS
#define WIN_RADIUS 2  // window radius -> default 5x5 window
#endif

// ---------- platform output helpers ----------
#ifdef HOST
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#else
/* SBI console putchar */
static inline void sbicon_putc(unsigned char c){
    register long a0 asm("a0") = (long)c;
    register long a7 asm("a7") = 1;
    asm volatile("ecall" : "+r"(a0) : "r"(a7) : "memory");
}
#endif

// ---------- small util: write 32-bit LE into buffer ----------
static inline void write_u32_le(unsigned char *b, uint32_t v){
    b[0] = (v >> 0) & 0xFF; b[1] = (v >> 8) & 0xFF; b[2] = (v >> 16) & 0xFF; b[3] = (v >> 24) & 0xFF;
}
static inline void write_f32_le(unsigned char *b, float f){
    union { float f; uint32_t u; } x; x.f = f;
    write_u32_le(b, x.u);
}

// ---------- buffers (static) ----------
#define W IMG_WIDTH
#define H IMG_HEIGHT
#define N_PIX (W*H)
#define N_FRAMES IMG_COUNT
#define GW (W+1)
#define GH (H+1)

// static working buffers (float)
static float I1[N_PIX];
static float I2[N_PIX];
static float Ix[N_PIX];
static float Iy[N_PIX];
static float It[N_PIX];

static float Ix2[N_PIX];
static float Iy2[N_PIX];
static float Ixy[N_PIX];
static float IxIt[N_PIX];
static float IyIt[N_PIX];

// integral images: (H+1)*(W+1)
static float int_Ix2[GH * GW];
static float int_Iy2[GH * GW];
static float int_Ixy[GH * GW];
static float int_IxIt[GH * GW];
static float int_IyIt[GH * GW];

// ---------- functions ----------
static void compute_gradients(const float *i1, const float *i2, float *ix, float *iy, float *it){
    for(int y=0;y<H;y++){
        for(int x=0;x<W;x++){
            int xl = (x==0)?x:x-1;
            int xr = (x==W-1)?x:x+1;
            int yu = (y==0)?y:y-1;
            int yd = (y==H-1)?y:y+1;
            int idx = y*W + x;
            ix[idx] = 0.5f * (i1[y*W + xr] - i1[y*W + xl] + i2[y*W + xr] - i2[y*W + xl]);
            iy[idx] = 0.5f * (i1[yd*W + x] - i1[yu*W + x] + i2[yd*W + x] - i2[yu*W + x]);
            it[idx] = i2[idx] - i1[idx];
        }
    }
}

static void build_integral(const float *src, float *intg){
    // intg has size GH * GW, zero first row
    for(int x=0;x<GW;x++) intg[x] = 0.0f;
    for(int y=1;y<=H;y++){
        float rowsum = 0.0f;
        int dst = y*GW;
        int srcrow = (y-1)*W;
        intg[dst + 0] = 0.0f;
        for(int x=1;x<=W;x++){
            rowsum += src[srcrow + (x-1)];
            intg[dst + x] = intg[dst - GW + x] + rowsum;
        }
    }
}

static float integral_sum(const float *intg, int x0, int y0, int x1, int y1){
    // intg coords offset by +1
    int Ax = x0;
    int Ay = y0;
    int Bx = x1 + 1;
    int By = y1 + 1;
    float A = intg[Ay*GW + Ax];
    float B = intg[Ay*GW + Bx];
    float C = intg[By*GW + Ax];
    float D = intg[By*GW + Bx];
    return D - B - C + A;
}

// ---------- Output helpers ----------
#ifdef HOST
static FILE *outf = NULL;
static int open_outfile(const char *fname, int w, int h, int out_frames){
    outf = fopen(fname, "wb");
    if(!outf) return -1;
    uint32_t wu = (uint32_t)w, hu = (uint32_t)h, nu = (uint32_t)out_frames;
    fwrite(&wu,4,1,outf); fwrite(&hu,4,1,outf); fwrite(&nu,4,1,outf);
    return 0;
}
static void write_float_to_file(float val){
    fwrite(&val, sizeof(float), 1, outf);
}
#else
static void send_bytes(const unsigned char *buf, size_t len){
    for(size_t i=0;i<len;i++) sbicon_putc(buf[i]);
}
static void stream_header(int w, int h, int out_frames){
    unsigned char hdr[12];
    write_u32_le(hdr + 0, (uint32_t)w);
    write_u32_le(hdr + 4, (uint32_t)h);
    write_u32_le(hdr + 8, (uint32_t)out_frames);
    send_bytes(hdr, 12);
}
static void stream_float(float f){
    unsigned char b[4];
    write_f32_le(b, f);
    send_bytes(b,4);
}
#endif

// ---------- main processing ----------
#ifdef HOST
int main(int argc, char **argv){
    if(argc < 3){
        fprintf(stderr,"Usage: %s <out_flow.raw> <window_radius(optional)>\n", argv[0]);
        return 1;
    }
    const char *outfname = argv[1];
    int radius = (argc>=3) ? atoi(argv[2]) : WIN_RADIUS;
    int out_frames = N_FRAMES - 1;
    if(out_frames <= 0){ fprintf(stderr,"Need >=2 frames\n"); return 1; }
    if(open_outfile(outfname, W, H, out_frames) != 0){ perror("open out"); return 1; }

    for(int f=0; f<out_frames; ++f){
        // copy frames into floats
        const uint8_t *p1 = frames[f];
        const uint8_t *p2 = frames[f+1];
        for(int i=0;i<N_PIX;i++){ I1[i] = (float)p1[i] / 255.0f; I2[i] = (float)p2[i] / 255.0f; }

        compute_gradients(I1,I2,Ix,Iy,It);
        for(int i=0;i<N_PIX;i++){
            float ix = Ix[i], iy = Iy[i], it = It[i];
            Ix2[i] = ix*ix; Iy2[i] = iy*iy; Ixy[i] = ix*iy;
            IxIt[i] = ix*it; IyIt[i] = iy*it;
        }
        build_integral(Ix2, int_Ix2);
        build_integral(Iy2, int_Iy2);
        build_integral(Ixy, int_Ixy);
        build_integral(IxIt, int_IxIt);
        build_integral(IyIt, int_IyIt);

        // compute per-pixel and write u then v
        for(int y=0;y<H;y++){
            int y0 = (y-radius) < 0 ? 0 : (y-radius);
            int y1 = (y+radius) >= H ? H-1 : (y+radius);
            for(int x=0;x<W;x++){
                int x0 = (x-radius) < 0 ? 0 : (x-radius);
                int x1 = (x+radius) >= W ? W-1 : (x+radius);
                float Sxx = integral_sum(int_Ix2, x0,y0,x1,y1);
                float Syy = integral_sum(int_Iy2, x0,y0,x1,y1);
                float Sxy = integral_sum(int_Ixy, x0,y0,x1,y1);
                float SxIt = integral_sum(int_IxIt, x0,y0,x1,y1);
                float SyIt = integral_sum(int_IyIt, x0,y0,x1,y1);
                float det = Sxx*Syy - Sxy*Sxy;
                float uval=0.0f, vval=0.0f;
                const float eps = 1e-6f;
                if(det > eps || det < -eps){
                    float inv = 1.0f / det;
                    uval = (-Syy * SxIt + Sxy * SyIt) * inv;
                    vval = ( Sxy * SxIt - Sxx * SyIt) * inv;
                }
                write_float_to_file(uval);
                write_float_to_file(vval);
            }
        }
        fprintf(stderr,"Processed frame %d/%d\n", f+1, out_frames);
    }
    fclose(outf);
    fprintf(stderr,"Saved flow to %s\n", outfname);
    return 0;
}
#else
int main(void){
    int radius = WIN_RADIUS;
    int out_frames = N_FRAMES - 1;
    if(out_frames <= 0){
        const char *err = "Need >=2 frames\n"; for(const char*s=err;*s;++s) sbicon_putc(*s); while(1) asm volatile("wfi");
    }
    // send header first
    stream_header(W, H, out_frames);

    for(int f=0; f<out_frames; ++f){
        const uint8_t *p1 = frames[f];
        const uint8_t *p2 = frames[f+1];
        for(int i=0;i<N_PIX;i++){ I1[i] = (float)p1[i] / 255.0f; I2[i] = (float)p2[i] / 255.0f; }

        compute_gradients(I1,I2,Ix,Iy,It);
        for(int i=0;i<N_PIX;i++){
            float ix = Ix[i], iy = Iy[i], it = It[i];
            Ix2[i] = ix*ix; Iy2[i] = iy*iy; Ixy[i] = ix*iy;
            IxIt[i] = ix*it; IyIt[i] = iy*it;
        }
        build_integral(Ix2, int_Ix2);
        build_integral(Iy2, int_Iy2);
        build_integral(Ixy, int_Ixy);
        build_integral(IxIt, int_IxIt);
        build_integral(IyIt, int_IyIt);

        for(int y=0;y<H;y++){
            int y0 = (y-radius) < 0 ? 0 : (y-radius);
            int y1 = (y+radius) >= H ? H-1 : (y+radius);
            for(int x=0;x<W;x++){
                int x0 = (x-radius) < 0 ? 0 : (x-radius);
                int x1 = (x+radius) >= W ? W-1 : (x+radius);
                float Sxx = integral_sum(int_Ix2, x0,y0,x1,y1);
                float Syy = integral_sum(int_Iy2, x0,y0,x1,y1);
                float Sxy = integral_sum(int_Ixy, x0,y0,x1,y1);
                float SxIt = integral_sum(int_IxIt, x0,y0,x1,y1);
                float SyIt = integral_sum(int_IyIt, x0,y0,x1,y1);
                float det = Sxx*Syy - Sxy*Sxy;
                float uval=0.0f, vval=0.0f;
                const float eps = 1e-6f;
                if(det > eps || det < -eps){
                    float inv = 1.0f / det;
                    uval = (-Syy * SxIt + Sxy * SyIt) * inv;
                    vval = ( Sxy * SxIt - Sxx * SyIt) * inv;
                }
                stream_float(uval);
                stream_float(vval);
            }
        }
        // optional progress message:
        const char *msg = "Frame done\n"; for(const char*s=msg;*s;++s) sbicon_putc(*s);
    }
    const char *end = "Done\n"; for(const char*s=end;*s;++s) sbicon_putc(*s);
    while(1) asm volatile("wfi");
    return 0;
}
#endif
